Поехали, как билдится mempool на уровне сервера. Короче, как билдится mempool на уровне сервера машины. Он получает на вход запросы, которые направляются либо к саб-машинам, либо выполняются в контексте самой машины-сервера, как и дальнейшие все в иерархии. Итак, mempool представляет собой закодированные в rlp эфира значения из набора ключей по bytes32 массива, и далее следует массив значений, которые по этим ключам надо передавать. Например, если 5 ключей и 7 значений, то первые 5 значений направляются в следующие под-машины, в данном случае в сайнеры, а последние 2 являются транзакциями, которые выполняются в контексте этой же машины, то есть транзакциями уровня машины. Например, создание нового сайнера. Итак, наша задача сделать сначала с транзакциями на уровне самой машины, допустим, простой counter plus 1, единственные транзакции. То есть мы запускаем серверную машину и раз в 100 миллисекунд искусственно создаем транзакцию на помещение каунтера. И запуская timeout loop, пропозер луп, так называемый, для серверной машины, он раз в 100 миллисекунд создает этот блок с этим инкрементирующей транзакцией. Соответственно, структура блока это ссылка на предыдущий блок, набор вот этих транзакций в виде mempool, это одна долгая длинная буферная строка, и хэш стейта, который содержит контент всех субмашин и состояние самой машины. Соответственно, это все пишется в leveldb под номером блока, точнее под хэшом блока. И также сохраняется в руте машины. Рут машины хранится по ключу id сервера, в данном случае это просто 0 в leveldb, а значение это rlp закодированное состояние машины в виде последнего блока. А, кстати, в данном случае тут нет консенсус блока, тут просто сразу вот этот вот собственный блок. Последний финализованный блок и является рутом машины в данном случае. Окей, у нас есть сервер, он крутится, и как к нему приходят сообщения? Им же должно что-то приходить? Да, сообщения приходят по веб-сокету, но при симуляции можно просто симулировать создание тайм-аутов разных сообщений извне. Итак, сообщения могут приходить к серверу как от юзера через юзер-валет, через кошелек со специальным токеном, тогда они считаются авторизованными. Также он может получать сообщения, которые направлены в отдельных entities. У нас, смотри, у нас пока не было сущности юзер, типа через валет оно приходит от entity. Ну, мы сейчас на каунтере просто. Да, я понимаю, я понимаю, я просто... Сайнеры где появляются в этом месте? Сервер, сайнеры. В сервер приходят извне все сообщения накапливаются, в сайнер приходят сообщения из юзер-валета, то есть ты сайнеру говоришь, я хочу... То есть смотри, у нас есть сервер, я просто обычный юзер, как я инициирую транзакцию, чтобы что-то поменялось в стрейте? Уже логики платежей или в каунтере? Да просто каунтер, я хочу каунтер, глобальный каунтер. Каунтер делается уже у нас прямо в контексте самого приложения в джойскрипте, в этом индексном файле. Он просто считает блоки, ты этот каунтер говоришь? Не, я говорю транзакцию в виде каунта, которая просто инкрементор. То есть мы реализуем одну, а в данном случае сам серверный файл, у нас же минимальная MVP. А в реальности все транзакции будут инстализированы либо через, соответственно, сам юзер-кошелек по токену, локальная HTML, которая в браузере общается с демоном этим сервером. Мы заведем на сервере мой личный каунтер. Я как юзер хочу инкрементировать на сервере мой каунтер. Ты имеешь в виду сайнерский каунтер? Да, просто прислать сообщение, сделай что-то. Тогда просто два уровня абстракции сразу делается, и сервер, и сайнер. В принципе, я думаю, можно сразу как раз заложить. Нет, это следующий шаг. Да, это следующий шаг. По сути, каунтер можно теперь создавать в любой из уровней машин, и ты просто таргетишь извне, когда ты сразу выбираешь, куда по уровню машины ты приходишь. Вот эта функция, которая либо WebSocket сервер, он ReceiveMessage, либо мы вручную вызываем, она просто получает, кто мне послал, то есть кто другой сайнер, другой сервер. Мы эту информацию знаем, и другой энтити, типа откуда оно изначально идет. И оно направлено тоже куда-то в моем сервере, в моем сайнере, и в одну из моих энтити. Это сообщение извне. Я, может, неправильно спросил. Смотри, может быть так, я юзер обычный, и у меня есть кошель. Я в кошельке, наверное, хочу увеличить, инкрементнуть каунтер. Вот это уже следующий уровень, это энтити. Я как юзер, куда я отправляю сообщение? Ты также присылаешь ее в этот WebSocket с таргетом с роутера. Кому я присылаю? К серверу. Потому что в рут, на входящий всегда все входит через сервер. И дальше он распределяет это на продюсеры. Ага, понял. На остальные, на сайнеры, на энтити, на каналы. И потом все это собирает, promise all, сохранил. Я как юзер, у меня просто есть какой-то приватный ключ, и я пошлю какой-то... Ну, токен, API токен, который просто сама консоль рисует, и она также в памяти хранится. То есть ты как юзер можешь создавать сообщение уровня как сервера, так и сайнера, более рутовые. То есть чем более старшая машина, тем больше у тебя контроль доступа над остальными. Ага. Тем более приоритетные ты задачи можешь ставить. А внешние энтити, они могут взаимодействовать только с энтити. Либо на этапе создания энтити они могут взаимодействовать с сайнерами. А, то есть считается, что ты авторизованный юзер, и твоя авторизация, она не связана с приватными ключами? Да, там API токен. То есть когда ты добавляешь свою транзакцию в mempool по API токену, то он сразу смотрит, можно ли тебе добавиться туда в этой очереди. Потому что очередь, вот эта mempool, она же иерархичная. То есть там ключи для следующего уровня, их значение для следующего уровня, плюс значение, можно все это в одну просто строчку закинуть, ты понял как я написал. Да, да, да. Ключи, значение и значение для той же самой сущности, без ключа уже. Ага. И, соответственно, ты в real-time разбиваешь это RLPH, и это простая функция, которая буферы либо encoded, либо decoded. И ты вот по этим ключам все в сайнеры, вот эти значения promise all послал, а вот эти в этот же момент начинаешь процессить на себе. Один за одной. Вот нам задача даже сейчас игнорировать вот эти вот ключи и значения. Сделать только на уровне самой серверной машины, counter, плюс 5, плюс 6, плюс 7. И state просто прибавляет число. А state можно хранить в виде просто закодированного JSON, просто в этом буфере или в RLPH просто, как число там нулевой integer. Шаг 0, мы просто делаем стейты в тупую, в лоб, без даже подписи. Мы просто... Да, да, да. А тут они не нужны, кстати. На уровне сервера подписи нет смысла делать, потому что подписывать тебе надо уровне выше. То есть, как минимум, entity надо подписывать, а вот сайнер можно даже тоже не подписывать, потому что тебе что надо подписывать? Только в той ситуации, когда кто-то за тобой эти блоки будет проверять и исполнять. А сайнер, его как бы нет смысла реплицировать. Для этого существуют entities, которые реплицируют. Короче, набираем вот эту иерархичную структуру из примитивных штук, которые ничего не верифицируют, они просто... Первые два уровня нет подписи практически. Да, да, да. Не, я про то, что дальше добавляем. Смотрим, добавляем подписи там, где они нужны, дальше добавляем блоки. Да, подписи это как бы security, навешать можно всегда потом. Сейчас главное, чтобы все... Да, кстати, да, можно даже без подписи блоки сначала сделать. Вообще все без подписи, все, забудь, что есть подписи. Ага, понял. Сначала блоки, потом подписи и только потом... Просто trust, что все правильно, скажем, изначально. Я все потом 10 раз проверю, список, что когда должно проверяться. Класс. Блин, самое красивое, что мне хочется больше всего закончить, тогда я скажу, типа, блядь, вот самая тяжелая часть пройдена. Это вот агрегированная подпись. То есть хочется, чтобы в коде логики было вот как sign и verify. Для обычного юзера это понятно. Он моментно, типа, в той же сущности регенерируется. А когда у тебя 10 юзеров, и ты сейчас выполняешь от лица оператора, и тут, от лица пропозера, и тут ты как бы подписываешься, но ты подписываешь как будто не единственная подпись, а сразу в свой слот, вот в этой агрегированной подписи ты даешь. И в прикоммитах ее тоже собираешь. И, соответственно, у тебя накапливается на все исходящие транзакции, на все хэши, которые ты там куда-то в депозитарии шлешь или дальше, либо генерируешь блоки для каналов. То есть это последний уровень виртуализации. То есть когда в Институте что-то происходит, она решает что-то сделать с каналами, то есть ты параллельно с передачей блока передаешь подписи, связанные с каналами. Но они не хранятся внутри самого блока, потому что это бы создало двойной луп. Ты понимаешь, почему? Вот у тебя 10 юзеров, и тебе надо агрегироваться на какое-то изменение. Вы уже решили, что вам надо делать платеж. Ты посылаешь на 10, типа я пропозию такой-то блок, дайте мне ваши прикоммиты. Они возвращают прикоммиты и подписи на все исходящие в результате вот этого блока, Транзакции, которые идут в каналы, то есть создание блоков в каналах, они моментально, если у тебя статус ready в канале, потому что у тебя два статуса может быть в канале, ready, ты можешь сейчас послать send, ты уже послал блок, ты ждешь ответа, ты не можешь сейчас послать блок. То есть он дуплексный, он должен получить acknowledgement, как синак. И, соответственно, у тебя набор хэшей, которые надо подписать, которые именно являются вот этими пропозами в каналах, которые были ready, еще надо учитывать. И их тоже надо подписать. Соответственно, они вместе с прикоммитами возвращают и подписи на вот эти все исходящие хэши. И у тебя сразу агрегируется 10 сообщений, 10 каналов, например, и все они тоже сразу подписаны. Потому что если бы это не делать, только тогда бы надо было отдельно им посылать хэш, и еще один раунд было бы взаимодействия, это очень долго. А надо сразу оптимизировать это для быстрого хаба. То есть, по сути, может быть, вот так выглядит. Пришел запрос на хаб из 4 дата-центров, он сразу послал на 3 остальных, вернули подписи и с подписями на канальные сообщения в следующий канал. То есть, это платеж, например, он дальше идет. И он сразу рассылает и вот этому бродкасту, и этому. После того, как он сделал батч в LevelDB, записался и начал рассылать. И этим прилетают тоже серверные мемпулы. Раз в 100 миллисекунд, хоп. Вот, и я вот в этом месте, я почему придумал яичных агентов, что нужно, чтобы все участники подписи групповой сказали, что да. Что они были онлайн, ну, грубо говоря. Ну, типа, финализация этих подписей должна происходить довольно быстро. Вот, и прикольно, что в определенных случаях это не 100% кейсов. Может быть, что у тебя есть просто и агент-бухгалтер, и он такой, а, нормальная процедура, это пропускаем, типа. А вот сейчас смотри, важное отличие, заметь. Мы говорили про подписи при коммите на блоке. Да. Но есть два вида. Все транзакции, что попали в блок, они автоматически все исполняются и выполняются. Почему? Потому что у нас уровень управления сущностей двухслойный. Транзакции что делают? Работают с пропозалами. И только когда пропозал набрал достаточное количество действий, происходят реальные действия внутри энтити. Почему? Потому что если бы мы разрешили одной транзакции все менять, тогда бы любой из 100 владельцев этой энтити мог бы взять и изменить, удалить ее, например. Поэтому любые важные изменения проходят через систему пропозалов, когда кворум сайнеров этой энтити договорились о чем-то, и только когда у них... И тут, кстати, важно сделать очень красивую и компактную систему, где будет просто храниться хэш, и на нем просто расти число voting shares. И когда оно пресекает какой-то кворум, в конце этого блока делается просто execute пропозал, который финализован. Кстати, в коде он как раз что-то похожее написал, finalized, expired proposals, чтобы это было все удобно просто по объекту JSON. И чтобы эти пропозалы выполнялись, то есть уже выполнялись приватные методы этой машины по сути, которые нельзя вызвать извне обычной транзакции, иначе бы это было просто компрометировать сущность. То есть двухслойная система контроля изменений в состоянии машины. Так, ну все, наверное.