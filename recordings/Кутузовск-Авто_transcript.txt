Агрегирующий слой, он хранит, считай, мапу, где ключ сайнера, двоеточие root этого сайнера, который является head, запятая, data. Это отдельная нода, так сказать, по хэшу вот этой вот штуки. И у сайнера внутри data хранится его приватный ключ, например. Также data делает ссылку на предыдущий финализованный блок, и тут накапливаются транзакции, которые она хочет запроцессить. При генезисе, когда ты только создал, создается сразу первый финализованный блок с пустыми тут значениями, никакого input, а в output попадает JSON в виде того, что мы сейчас запишем. И, соответственно, когда новые транзакции залетают сюда в root, применяются, так сказать, apply к этой части дага, к этой ноде. Так как это сайнер, ему не нужно с кем-то кооперироваться, он сам отвечает. По идее, он даже не реплицируется нигде, это только у тебя локально, это дерево существует. Транзакции сразу капают сюда, в input следующего блока, они накопились, и к концу определенного слота, каждый, допустим, 500 миллисекунд, уже на уровне всей системы, всех сайнеров, а от root идет, и по всей цепочке объекта спускается, и он начинает их... Подожди, сначала надо ему отправить блок, то есть новый финализованный блок создаётся. Так как ты сам сайнер, ты берешь приватный ключ и сдвигаешь, то есть этот сохраняешь как предыдущий, и ссылочку теперь в head передвигаешь на этот финализованный блок. У нас пока простые будут транзакции, даже как канал не нужен, допустим, сайнер просто metamask-like wallet, который получает в виде ивентов из депозитория, когда пришли деньги в каком-то токене, и создает транзакции в депозитории, чтобы их куда-то дальше двинуть. Мне их каналов не нужно. То есть он может свой локальный стейк апдейтнуть, когда получил ивент, и записать там блок, или он может... Он его сюда посылает, как transition, и этот ивент, и когда он финализуется, то есть когда происходит подписывание и применяется, типа, commit блока к вот этому состоянию, и сюда попадает финальный блок, то считается, что состояние этой стейк-тайм-машины, оно теперь вот это финальное, который в нашем случае JSON, в реальности это будет Merkle по 33, с более сложной системой key-value значений. То же самое, как storage хранится у любого контракта в эфире, потому что это для больших ключей. Допустим, у тебя 100 депозитариев по 1000 токенов каждый, уже JSON неэффективно становится. Но достаточно данного момента этого. Соответственно, ивент пришел, у тебя поменялось значение в ауте. Когда ты хочешь поменять, сдвинуть значение резервов какого-то токена третьему лицу, ты создаешь, опять-таки, пропозал, потому что entity реагирует на пропозал, и он также отправляется сюда, и автоматически превращается в следующий финальный блок, где в результате выполнения этого пропозала, тебе надо бы сгенерировать подпись. Подпись можно в рантайме сгенерировать, и в рантайме ее, собственно, сюда и засунуть. И, соответственно, у тебя в стейте теперь находятся полностью подписанные транзакции, и уже оператор рассылает ее в депозитарий. А кто в данном случае оператор? Ну, просто JavaScript нода. А, я понял, то твой клиент, твое приложение. Приложение, да, на самом основном уровне. И она отправила транзакцию, убеждается, что она там включилась в блок, и как только она включилась, то опять-таки назад получает ивент, типа вычитаем из резерва, который потратили, опять ивент сюда залетает, следующий блок, обновили состояние. Теперь, если ты хочешь создать канал к другому участнику, ты шлешь запрос, типа, пингани в свою сущность, пингани второго участника Боба, и теперь уже также транзакция сюда залетает и финализуется, и в этот момент она внутри вот этого аута создает... Но мы должны получить от второго участника что? Создает внутри себя такую же стейтай-машину, с таким же head-data, значит, по ключу, тут два варианта. Либо использовать ключ, как entity-адрес второго участника, либо использовать ключом entity-адрес канала вашего с этим участником, то есть, где первый твой будет entity, второй его, зависит от того, кто ли вы правы. Вот, в принципе, и тот и тот вариант подходит. Второй более генерализованный, потому что он подразумевает, что у тебя дерево всегда по ключу, те сущности, в которых parent является, типа, участником, а в случае с каналом ты просто упрощаешь, потому что, так как ты и так один из участников, тебе просто достаточно указать второго. Можно остановиться на втором варианте, потому что канал все-таки основное вообще, что делает этот реализованный. Так вот, что он делает? Он создает по ключу, значит, второго участника Боба новое значение в этом мир-кле-дереве, в нашем случае простая мапа, head-data вот эту. И первое, что он делает, надо ему создать genesis-блок, он еще не подписан, поэтому он не может создать первый финальный блок сразу, поэтому он создает proposed-блок, то есть data это, как бы, собирательное для proposed-блока и для всякой фигни, там, mempool. mempool это, как бы, вторая еще очередь, типа, у тебя висит proposed-блок, ты куда будешь транзакции новые залетающие отправлять? В mempool. Соответственно, так как ты только что это все инициализировал, у тебя создается proposed-блок в виде, типа, давай создадим канал, ты делаешь подпись этого в рантайме и возвращаешь, значит, event в виде того, на какую ноду отправить сообщение и какое сообщение, в данном случае сообщением является proposed-блок, commit, например, просто, то есть все consensus-related сообщения можно реализовать в виде одного общего метода, commit, который может содержать предложенный блок и твою подпись на него, либо подпись на тот блок, что тебе предложили, просто, значит, из-за того, что тебе пришло, так ты это интерпретируешь, необязательно отдельные методы создавать, вот, ты, значит, закоммитил, значит, сообщение в виде ping-блока, типа, я хочу создать с тобой канал, и первую свою подпись послал, и этим event-ом ты его посылаешь из сущности канала в entity, которая это все реализовала, и entity должна послать его уже по своим вебсокетам тому, с кем она хочет завести этот канал, а так как в данном случае все живет в одной агрегационной базе с тем, то она даже может вебсокетом не пользоваться, а внутри себя просто перенаправить раунд такой. Ждать потом сень, как с второй стороны? Скажем так, перенаправить не по вебсокету, а добавить свой собственный mempool, и input, так сказать, соответственно, агрегирующая с тем, она тоже создает блоки каждые 500 миллисекунд, или 100 миллисекунд, и, соответственно, когда она начинает работать на следующем уже, то она берет те накопленные сообщения, которые она сама себе послала, и уже теперь отправляет во вторую систему, которая получает ее на вход, моментально финализует через свой первый уровень, потому что у него есть ключ своей же сущности, и попадает в output, там у каждого сообщения from to, от кого к кому, и в данном случае она использует from как ключ, потому что это теперь его counterparty, и автоматически создает канал, и вот тут нужный элемент хэш кэша как раз убедиться, что тебя не спайдят, это в рантайме можно проверить, никак не сохранять, это пока скипнем,